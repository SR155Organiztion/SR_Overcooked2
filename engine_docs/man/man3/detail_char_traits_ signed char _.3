.TH "detail::char_traits< signed char >" 3 "Version 1.0" "Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
detail::char_traits< signed char >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <json\&.hpp>\fP
.PP
std::char_traits< signed char >, std::char_traits< char >를(을) 상속했습니다\&.
.SS "Public 타입"

.in +1c
.ti -1c
.RI "using \fBchar_type\fP = signed char"
.br
.ti -1c
.RI "using \fBint_type\fP = uint64_t"
.br
.in -1c
.SS "정적 Public 멤버 함수"

.in +1c
.ti -1c
.RI "static \fBint_type\fP \fBto_int_type\fP (\fBchar_type\fP c) noexcept"
.br
.ti -1c
.RI "static \fBchar_type\fP \fBto_char_type\fP (\fBint_type\fP i) noexcept"
.br
.ti -1c
.RI "static constexpr \fBint_type\fP \fBeof\fP () noexcept"
.br
.in -1c
.SH "상세한 설명"
.PP 
\fBjson\&.hpp\fP 파일의 \fB3765\fP 번째 라인에서 정의되었습니다\&.
.SH "멤버 타입정의 문서화"
.PP 
.SS "using \fBdetail::char_traits\fP< signed char >::char_type = signed char"

.PP
\fBjson\&.hpp\fP 파일의 \fB3767\fP 번째 라인에서 정의되었습니다\&.
.SS "using \fBdetail::char_traits\fP< signed char >::int_type = uint64_t"

.PP
\fBjson\&.hpp\fP 파일의 \fB3768\fP 번째 라인에서 정의되었습니다\&.
.SH "멤버 함수 문서화"
.PP 
.SS "constexpr \fBint_type\fP \fBdetail::char_traits\fP< signed char >::eof ()\fR [inline]\fP, \fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB3781\fP 번째 라인에서 정의되었습니다\&.
.SS "\fBchar_type\fP \fBdetail::char_traits\fP< signed char >::to_char_type (\fBint_type\fP i)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB3776\fP 번째 라인에서 정의되었습니다\&.
.SS "\fBint_type\fP \fBdetail::char_traits\fP< signed char >::to_int_type (\fBchar_type\fP c)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB3771\fP 번째 라인에서 정의되었습니다\&.

.SH "작성자"
.PP 
소스 코드로부터 Engine를 위해 Doxygen에 의해 자동으로 생성됨\&.
