.TH "basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >" 3 "Version 1.0" "Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > \- namespace for Niels Lohmann  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <json\&.hpp>\fP
.PP
nlohmann::detail::json_base_class< void >를(을) 상속했습니다\&.
.SS "Public 타입"

.in +1c
.ti -1c
.RI "using \fBvalue_t\fP = \fBdetail::value_t\fP"
.br
.ti -1c
.RI "using \fBjson_pointer\fP = ::nlohmann::json_pointer<StringType>"
.br
.RI "JSON Pointer, see \fBnlohmann::json_pointer\fP "
.ti -1c
.RI "template<typename T, typename SFINAE> using \fBjson_serializer\fP = JSONSerializer<T, SFINAE>"
.br
.ti -1c
.RI "using \fBerror_handler_t\fP = \fBdetail::error_handler_t\fP"
.br
.RI "how to treat decoding errors "
.ti -1c
.RI "using \fBcbor_tag_handler_t\fP = \fBdetail::cbor_tag_handler_t\fP"
.br
.RI "how to treat CBOR tags "
.ti -1c
.RI "using \fBbjdata_version_t\fP = \fBdetail::bjdata_version_t\fP"
.br
.RI "how to encode BJData "
.ti -1c
.RI "using \fBinitializer_list_t\fP = std::initializer_list<\fBdetail::json_ref\fP<\fBbasic_json\fP>>"
.br
.RI "helper type for initializer lists of \fBbasic_json\fP values "
.ti -1c
.RI "using \fBinput_format_t\fP = \fBdetail::input_format_t\fP"
.br
.ti -1c
.RI "using \fBjson_sax_t\fP = \fBjson_sax\fP<\fBbasic_json\fP>"
.br
.RI "SAX interface type, see \fBnlohmann::json_sax\fP "
.ti -1c
.RI "using \fBparse_event_t\fP = \fBdetail::parse_event_t\fP"
.br
.RI "parser event types "
.ti -1c
.RI "using \fBparser_callback_t\fP = \fBdetail::parser_callback_t\fP<\fBbasic_json\fP>"
.br
.RI "per-element parser callback type "
.in -1c
.SS "Public 멤버 함수"

.in +1c
.ti -1c
.RI "\fBJSON_HEDLEY_RETURNS_NON_NULL\fP const char * \fBtype_name\fP () const noexcept"
.br
.RI "return the type as string "
.ti -1c
.RI "\fBdata\fP (const \fBvalue_t\fP v)"
.br
.ti -1c
.RI "\fBdata\fP (\fBsize_type\fP cnt, const \fBbasic_json\fP &val)"
.br
.ti -1c
.RI "\fBdata\fP () noexcept=default"
.br
.ti -1c
.RI "\fBdata\fP (data &&) noexcept=default"
.br
.ti -1c
.RI "\fBdata\fP (const data &) noexcept=delete"
.br
.ti -1c
.RI "\fBdata\fP & \fBoperator=\fP (\fBdata\fP &&) noexcept=delete"
.br
.ti -1c
.RI "\fBdata\fP & \fBoperator=\fP (const \fBdata\fP &) noexcept=delete"
.br
.ti -1c
.RI "\fB~data\fP () noexcept"
.br
.in -1c
.SS "정적 Public 멤버 함수"

.in +1c
.ti -1c
.RI "static \fBallocator_type\fP \fBget_allocator\fP ()"
.br
.RI "returns the allocator associated with the container "
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBmeta\fP ()"
.br
.RI "returns version information on the library "
.ti -1c
.RI "\fBJSON_PRIVATE_UNLESS_TESTED\fP \fBconst_reference\fP bool static SAX bool \fBsax_parse\fP (InputType &&i, SAX *sax, \fBinput_format_t\fP format=input_format_t::json, const bool strict=true, const bool ignore_comments=false, const bool ignore_trailing_commas=false)"
.br
.ti -1c
.RI "template<class IteratorType, class SAX> static bool \fBsax_parse\fP (IteratorType first, IteratorType last, SAX *sax, \fBinput_format_t\fP format=input_format_t::json, const bool strict=true, const bool ignore_comments=false, const bool ignore_trailing_commas=false)"
.br
.RI "generate SAX events "
.ti -1c
.RI "template<typename SAX> static bool \fBsax_parse\fP (\fBdetail::span_input_adapter\fP &&i, SAX *sax, \fBinput_format_t\fP format=input_format_t::json, const bool strict=true, const bool ignore_comments=false, const bool ignore_trailing_commas=false)"
.br
.RI "generate SAX events "
.in -1c
.SS "Public 속성"

.in +1c
.ti -1c
.RI "\fBJSON_PRIVATE_UNLESS_TESTED\fP : struct \fBdata\fP { \fBvalue_t\fP m_type = value_t::null"
.br
.ti -1c
.RI "json_value \fBm_value\fP = {}"
.br
.RI "the value of the current element "
.ti -1c
.RI "\fBdata\fP \fBm_data\fP = {}"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<\fBdetail::value_t\fP> struct \fBdetail::external_constructor\fP"
.br
.ti -1c
.RI "template<typename> class \fB::nlohmann::json_pointer\fP"
.br
.ti -1c
.RI "template<typename BasicJsonType, typename InputType> class \fB::nlohmann::detail::parser\fP"
.br
.ti -1c
.RI "template<typename BasicJsonType> class \fB::nlohmann::detail::iter_impl\fP"
.br
.ti -1c
.RI "template<typename BasicJsonType, typename CharType> class \fB::nlohmann::detail::binary_writer\fP"
.br
.ti -1c
.RI "template<typename BasicJsonType, typename InputType, typename SAX> class \fB::nlohmann::detail::binary_reader\fP"
.br
.ti -1c
.RI "template<typename BasicJsonType, typename InputAdapterType> class \fB::nlohmann::detail::json_sax_dom_parser\fP"
.br
.ti -1c
.RI "template<typename BasicJsonType, typename InputAdapterType> class \fB::nlohmann::detail::json_sax_dom_callback_parser\fP"
.br
.ti -1c
.RI "class \fB::nlohmann::detail::exception\fP"
.br
.ti -1c
.RI "std::istream & \fBoperator<<\fP (\fBbasic_json\fP &j, std::istream &i)"
.br
.RI "deserialize from stream "
.ti -1c
.RI "std::istream & \fBoperator>>\fP (std::istream &i, \fBbasic_json\fP &j)"
.br
.RI "deserialize from stream "
.in -1c
.SS "element access"
Access to the JSON value\&. 
.in +1c
.ti -1c
.RI "\fBreference\fP \fBat\fP (\fBsize_type\fP idx)"
.br
.RI "access specified array element with bounds checking "
.ti -1c
.RI "\fBconst_reference\fP \fBat\fP (\fBsize_type\fP idx) const"
.br
.RI "access specified array element with bounds checking "
.ti -1c
.RI "\fBreference\fP \fBat\fP (const typename object_t::key_type &key)"
.br
.RI "access specified object element with bounds checking "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBreference\fP \fBat\fP (KeyType &&key)"
.br
.RI "access specified object element with bounds checking "
.ti -1c
.RI "\fBconst_reference\fP \fBat\fP (const typename object_t::key_type &key) const"
.br
.RI "access specified object element with bounds checking "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBat\fP (KeyType &&key) const"
.br
.RI "access specified object element with bounds checking "
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (\fBsize_type\fP idx)"
.br
.RI "access specified array element "
.ti -1c
.RI "\fBconst_reference\fP \fBoperator[]\fP (\fBsize_type\fP idx) const"
.br
.RI "access specified array element "
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (typename object_t::key_type key)"
.br
.RI "access specified object element "
.ti -1c
.RI "\fBconst_reference\fP \fBoperator[]\fP (const typename object_t::key_type &key) const"
.br
.RI "access specified object element "
.ti -1c
.RI "template<typename T> \fBreference\fP \fBoperator[]\fP (T *key)"
.br
.ti -1c
.RI "template<typename T> \fBconst_reference\fP \fBoperator[]\fP (T *key) const"
.br
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBreference\fP \fBoperator[]\fP (KeyType &&key)"
.br
.RI "access specified object element "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBoperator[]\fP (KeyType &&key) const"
.br
.RI "access specified object element "
.ti -1c
.RI "template<class ValueType, \fBdetail::enable_if_t\fP< !\fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&\fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBvalue\fP (const typename object_t::key_type &key, const ValueType &default_value) const"
.br
.RI "access specified object element with default value "
.ti -1c
.RI "template<class ValueType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< !\fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&\fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBvalue\fP (const typename object_t::key_type &key, ValueType &&default_value) const"
.br
.RI "access specified object element with default value "
.ti -1c
.RI "template<class ValueType, class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&!\fBdetail::is_json_pointer\fP< KeyType >::value &&\fBis_comparable_with_object_key\fP< KeyType >::value &&\fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBvalue\fP (KeyType &&key, const ValueType &default_value) const"
.br
.RI "access specified object element with default value "
.ti -1c
.RI "template<class ValueType, class KeyType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< \fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&!\fBdetail::is_json_pointer\fP< KeyType >::value &&\fBis_comparable_with_object_key\fP< KeyType >::value &&\fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBvalue\fP (KeyType &&key, ValueType &&default_value) const"
.br
.RI "access specified object element via JSON Pointer with default value "
.ti -1c
.RI "template<class ValueType, \fBdetail::enable_if_t\fP< \fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBvalue\fP (const \fBjson_pointer\fP &ptr, const ValueType &default_value) const"
.br
.RI "access specified object element via JSON Pointer with default value "
.ti -1c
.RI "template<class ValueType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< \fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBvalue\fP (const \fBjson_pointer\fP &ptr, ValueType &&default_value) const"
.br
.RI "access specified object element via JSON Pointer with default value "
.ti -1c
.RI "template<class ValueType, class BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >::value &&\fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBvalue\fP (const ::nlohmann::json_pointer< BasicJsonType > &ptr, const ValueType &default_value) const"
.br
.ti -1c
.RI "template<class ValueType, class BasicJsonType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >::value &&\fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBvalue\fP (const ::nlohmann::json_pointer< BasicJsonType > &ptr, ValueType &&default_value) const"
.br
.ti -1c
.RI "\fBreference\fP \fBfront\fP ()"
.br
.RI "access the first element "
.ti -1c
.RI "\fBconst_reference\fP \fBfront\fP () const"
.br
.RI "access the first element "
.ti -1c
.RI "\fBreference\fP \fBback\fP ()"
.br
.RI "access the last element "
.ti -1c
.RI "\fBconst_reference\fP \fBback\fP () const"
.br
.RI "access the last element "
.ti -1c
.RI "template<class IteratorType, \fBdetail::enable_if_t\fP< std::is_same< IteratorType, typename basic_json_t::iterator >\fB::value\fP||std::is_same< IteratorType, typename basic_json_t::const_iterator >\fB::value\fP, int > = 0> IteratorType \fBerase\fP (IteratorType pos)"
.br
.RI "remove element given an iterator "
.ti -1c
.RI "template<class IteratorType, \fBdetail::enable_if_t\fP< std::is_same< IteratorType, typename basic_json_t::iterator >\fB::value\fP||std::is_same< IteratorType, typename basic_json_t::const_iterator >\fB::value\fP, int > = 0> IteratorType \fBerase\fP (IteratorType first, IteratorType last)"
.br
.RI "remove elements given an iterator range "
.ti -1c
.RI "\fBsize_type\fP \fBerase\fP (const typename object_t::key_type &key)"
.br
.RI "remove element from a JSON object given a key "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBsize_type\fP \fBerase\fP (KeyType &&key)"
.br
.RI "remove element from a JSON object given a key "
.ti -1c
.RI "void \fBerase\fP (const \fBsize_type\fP idx)"
.br
.RI "remove element from a JSON array given an index "
.in -1c
.SS "exceptions"
Classes to implement user-defined exceptions\&. 
.in +1c
.ti -1c
.RI "using \fBexception\fP = \fBdetail::exception\fP"
.br
.ti -1c
.RI "using \fBparse_error\fP = \fBdetail::parse_error\fP"
.br
.ti -1c
.RI "using \fBinvalid_iterator\fP = \fBdetail::invalid_iterator\fP"
.br
.ti -1c
.RI "using \fBtype_error\fP = \fBdetail::type_error\fP"
.br
.ti -1c
.RI "using \fBout_of_range\fP = \fBdetail::out_of_range\fP"
.br
.ti -1c
.RI "using \fBother_error\fP = \fBdetail::other_error\fP"
.br
.in -1c
.SS "container types"
The canonic container types to use \fBbasic_json\fP like any other STL container\&. 
.in +1c
.ti -1c
.RI "using \fBvalue_type\fP = \fBbasic_json\fP"
.br
.RI "the type of elements in a \fBbasic_json\fP container "
.ti -1c
.RI "using \fBreference\fP = \fBvalue_type\fP&"
.br
.RI "the type of an element reference "
.ti -1c
.RI "using \fBconst_reference\fP = const \fBvalue_type\fP&"
.br
.RI "the type of an element const reference "
.ti -1c
.RI "using \fBdifference_type\fP = std::ptrdiff_t"
.br
.RI "a type to represent differences between iterators "
.ti -1c
.RI "using \fBsize_type\fP = std::size_t"
.br
.RI "a type to represent container sizes "
.ti -1c
.RI "using \fBallocator_type\fP = AllocatorType<\fBbasic_json\fP>"
.br
.RI "the allocator type "
.ti -1c
.RI "using \fBpointer\fP = typename std::allocator_traits<\fBallocator_type\fP>::pointer"
.br
.RI "the type of an element pointer "
.ti -1c
.RI "using \fBconst_pointer\fP = typename std::allocator_traits<\fBallocator_type\fP>::const_pointer"
.br
.RI "the type of an element const pointer "
.ti -1c
.RI "using \fBiterator\fP = \fBiter_impl\fP<\fBbasic_json\fP>"
.br
.RI "an iterator for a \fBbasic_json\fP container "
.ti -1c
.RI "using \fBconst_iterator\fP = \fBiter_impl\fP<const \fBbasic_json\fP>"
.br
.RI "a const iterator for a \fBbasic_json\fP container "
.ti -1c
.RI "using \fBreverse_iterator\fP = json_reverse_iterator<typename \fBbasic_json::iterator\fP>"
.br
.RI "a reverse iterator for a \fBbasic_json\fP container "
.ti -1c
.RI "using \fBconst_reverse_iterator\fP = json_reverse_iterator<typename \fBbasic_json::const_iterator\fP>"
.br
.RI "a const reverse iterator for a \fBbasic_json\fP container "
.in -1c
.SS "JSON value data types"
The data types to store a JSON value\&. These types are derived from the template arguments passed to class \fBbasic_json\fP\&. 
.in +1c
.ti -1c
.RI "using \fBdefault_object_comparator_t\fP = std::less<StringType>"
.br
.RI "default object key comparator type The actual object key comparator type (\fBobject_comparator_t\fP) may be different\&. "
.ti -1c
.RI "using \fBobject_t\fP"
.br
.RI "a type for an object "
.ti -1c
.RI "using \fBarray_t\fP = ArrayType<\fBbasic_json\fP, AllocatorType<\fBbasic_json\fP>>"
.br
.RI "a type for an array "
.ti -1c
.RI "using \fBstring_t\fP = StringType"
.br
.RI "a type for a string "
.ti -1c
.RI "using \fBboolean_t\fP = BooleanType"
.br
.RI "a type for a boolean "
.ti -1c
.RI "using \fBnumber_integer_t\fP = NumberIntegerType"
.br
.RI "a type for a number (integer) "
.ti -1c
.RI "using \fBnumber_unsigned_t\fP = NumberUnsignedType"
.br
.RI "a type for a number (unsigned) "
.ti -1c
.RI "using \fBnumber_float_t\fP = NumberFloatType"
.br
.RI "a type for a number (floating-point) "
.ti -1c
.RI "using \fBbinary_t\fP = nlohmann::byte_container_with_subtype<BinaryType>"
.br
.RI "a type for a packed binary type "
.ti -1c
.RI "using \fBobject_comparator_t\fP = \fBdetail::actual_object_comparator_t\fP<\fBbasic_json\fP>"
.br
.RI "object key comparator type "
.in -1c
.SS "modifiers"

.in +1c
.ti -1c
.RI "void \fBswap\fP (\fBreference\fP left, \fBreference\fP right) noexcept(std::is_nothrow_move_constructible< \fBvalue_t\fP >\fB::value\fP &&std::is_nothrow_move_assignable< \fBvalue_t\fP >\fB::value\fP &&std::is_nothrow_move_constructible< json_value >\fB::value\fP &&//NOLINT(cppcoreguidelines\-noexcept\-swap, performance\-noexcept\-swap) std::is_nothrow_move_assignable< json_value >\fB::value\fP)"
.br
.RI "exchanges the values "
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.RI "clears the contents "
.ti -1c
.RI "void \fBpush_back\fP (\fBbasic_json\fP &&val)"
.br
.RI "add an object to an array "
.ti -1c
.RI "\fBreference\fP \fBoperator+=\fP (\fBbasic_json\fP &&val)"
.br
.RI "add an object to an array "
.ti -1c
.RI "void \fBpush_back\fP (const \fBbasic_json\fP &val)"
.br
.RI "add an object to an array "
.ti -1c
.RI "\fBreference\fP \fBoperator+=\fP (const \fBbasic_json\fP &val)"
.br
.RI "add an object to an array "
.ti -1c
.RI "void \fBpush_back\fP (const typename object_t::value_type &val)"
.br
.RI "add an object to an object "
.ti -1c
.RI "\fBreference\fP \fBoperator+=\fP (const typename object_t::value_type &val)"
.br
.RI "add an object to an object "
.ti -1c
.RI "void \fBpush_back\fP (\fBinitializer_list_t\fP init)"
.br
.RI "add an object to an object "
.ti -1c
.RI "\fBreference\fP \fBoperator+=\fP (\fBinitializer_list_t\fP init)"
.br
.RI "add an object to an object "
.ti -1c
.RI "template<class\&.\&.\&. Args> \fBreference\fP \fBemplace_back\fP (Args &&\&.\&.\&. args)"
.br
.RI "add an object to an array "
.ti -1c
.RI "template<class\&.\&.\&. Args> std::pair< \fBiterator\fP, bool > \fBemplace\fP (Args &&\&.\&.\&. args)"
.br
.RI "add an object to an object if key does not exist "
.ti -1c
.RI "template<typename\&.\&.\&. Args> \fBiterator\fP \fBinsert_iterator\fP (\fBconst_iterator\fP pos, Args &&\&.\&.\&. args)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, const \fBbasic_json\fP &val)"
.br
.RI "inserts element into array "
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, \fBbasic_json\fP &&val)"
.br
.RI "inserts element into array "
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, \fBsize_type\fP cnt, const \fBbasic_json\fP &val)"
.br
.RI "inserts copies of element into array "
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, \fBconst_iterator\fP first, \fBconst_iterator\fP last)"
.br
.RI "inserts range of elements into array "
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, \fBinitializer_list_t\fP ilist)"
.br
.RI "inserts elements from initializer list into array "
.ti -1c
.RI "void \fBinsert\fP (\fBconst_iterator\fP first, \fBconst_iterator\fP last)"
.br
.RI "inserts range of elements into object "
.ti -1c
.RI "void \fBupdate\fP (\fBconst_reference\fP j, bool merge_objects=false)"
.br
.RI "updates a JSON object from another object, overwriting existing keys "
.ti -1c
.RI "void \fBupdate\fP (\fBconst_iterator\fP first, \fBconst_iterator\fP last, bool merge_objects=false)"
.br
.RI "updates a JSON object from another object, overwriting existing keys "
.ti -1c
.RI "void \fBswap\fP (\fBreference\fP other) noexcept(std::is_nothrow_move_constructible< \fBvalue_t\fP >\fB::value\fP &&std::is_nothrow_move_assignable< \fBvalue_t\fP >\fB::value\fP &&std::is_nothrow_move_constructible< json_value >\fB::value\fP &&//NOLINT(cppcoreguidelines\-noexcept\-swap, performance\-noexcept\-swap) std::is_nothrow_move_assignable< json_value >\fB::value\fP)"
.br
.RI "exchanges the values "
.ti -1c
.RI "void \fBswap\fP (\fBarray_t\fP &other)"
.br
.RI "exchanges the values "
.ti -1c
.RI "void \fBswap\fP (\fBobject_t\fP &other)"
.br
.RI "exchanges the values "
.ti -1c
.RI "void \fBswap\fP (\fBstring_t\fP &other)"
.br
.RI "exchanges the values "
.ti -1c
.RI "void \fBswap\fP (\fBbinary_t\fP &other)"
.br
.RI "exchanges the values "
.ti -1c
.RI "void \fBswap\fP (typename binary_t::container_type &other)"
.br
.RI "exchanges the values "
.in -1c
.SS "lexicographical comparison operators"

.in +1c
.ti -1c
.RI "\fBJSON_PRIVATE_UNLESS_TESTED\fP : static bool compares_unordered(\fBconst_reference\fP lhs"
.br
.ti -1c
.RI "\fBJSON_PRIVATE_UNLESS_TESTED\fP \fBconst_reference\fP \fBrhs\fP"
.br
.ti -1c
.RI "\fBJSON_PRIVATE_UNLESS_TESTED\fP \fBconst_reference\fP bool \fBinverse\fP"
.br
.in -1c
.SS "value access"
Direct access to the stored value of a JSON value\&. 
.in +1c
.ti -1c
.RI "template<typename PointerType, typename std::enable_if< std::is_pointer< PointerType >\fB::value\fP, int >\fB::type\fP = 0> auto \fBget_ptr\fP () noexcept \-> decltype(std::declval< basic_json_t & >()\&.get_impl_ptr(std::declval< PointerType >()))"
.br
.RI "get a pointer value (implicit) "
.ti -1c
.RI "template<typename PointerType, typename std::enable_if< std::is_pointer< PointerType >\fB::value\fP &&std::is_const< typename std::remove_pointer< PointerType >\fB::type\fP >\fB::value\fP, int >\fB::type\fP = 0> constexpr auto \fBget_ptr\fP () const noexcept \-> decltype(std::declval< const basic_json_t & >()\&.get_impl_ptr(std::declval< PointerType >()))"
.br
.RI "get a pointer value (implicit) "
.ti -1c
.RI "template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>> auto \fBget\fP () const noexcept(noexcept(std::declval< const basic_json_t & >()\&.template get_impl< ValueType >(\fBdetail::priority_tag\fP< 4 > {}))) \-> decltype(std::declval< const basic_json_t & >()\&.template get_impl< ValueType >(\fBdetail::priority_tag\fP< 4 > {}))"
.br
.RI "get a (pointer) value (explicit) "
.ti -1c
.RI "template<typename PointerType, typename std::enable_if< std::is_pointer< PointerType >\fB::value\fP, int >\fB::type\fP = 0> auto \fBget\fP () noexcept \-> decltype(std::declval< basic_json_t & >()\&.template \fBget_ptr\fP< PointerType >())"
.br
.RI "get a pointer value (explicit) "
.ti -1c
.RI "template<typename ValueType, \fBdetail::enable_if_t\fP< !\fBdetail::is_basic_json\fP< ValueType >\fB::value\fP &&\fBdetail::has_from_json\fP< basic_json_t, ValueType >\fB::value\fP, int > = 0> ValueType & \fBget_to\fP (ValueType &v) const noexcept(noexcept(JSONSerializer< ValueType >::from_json(std::declval< const basic_json_t & >(), v)))"
.br
.RI "get a value (explicit) "
.ti -1c
.RI "template<typename ValueType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< ValueType >\fB::value\fP, int > = 0> ValueType & \fBget_to\fP (ValueType &v) const"
.br
.ti -1c
.RI "template<typename T, std::size_t N, typename Array = T (&)[N], \fBdetail::enable_if_t\fP< \fBdetail::has_from_json\fP< basic_json_t, Array >\fB::value\fP, int > = 0> Array \fBget_to\fP (T(&v)[N]) const noexcept(noexcept(JSONSerializer< Array >::from_json(std::declval< const basic_json_t & >(), v)))"
.br
.ti -1c
.RI "template<typename ReferenceType, typename std::enable_if< std::is_reference< ReferenceType >\fB::value\fP, int >\fB::type\fP = 0> ReferenceType \fBget_ref\fP ()"
.br
.RI "get a reference value (implicit) "
.ti -1c
.RI "template<typename ReferenceType, typename std::enable_if< std::is_reference< ReferenceType >\fB::value\fP &&std::is_const< typename std::remove_reference< ReferenceType >\fB::type\fP >\fB::value\fP, int >\fB::type\fP = 0> ReferenceType \fBget_ref\fP () const"
.br
.RI "get a reference value (implicit) "
.ti -1c
.RI "template<typename ValueType, typename std::enable_if< \fBdetail::conjunction\fP< \fBdetail::negation\fP< std::is_pointer< ValueType > >, \fBdetail::negation\fP< std::is_same< ValueType, std::nullptr_t > >, \fBdetail::negation\fP< std::is_same< ValueType, \fBdetail::json_ref\fP< \fBbasic_json\fP > > >, \fBdetail::negation\fP< std::is_same< ValueType, typename string_t::value_type > >, \fBdetail::negation\fP< \fBdetail::is_basic_json\fP< ValueType > >, \fBdetail::negation\fP< std::is_same< ValueType, std::initializer_list< typename string_t::value_type > > >, \fBdetail::is_detected_lazy\fP< \fBdetail::get_template_function\fP, const basic_json_t &, ValueType > >\fB::value\fP, int >\fB::type\fP = 0> \fBJSON_EXPLICIT\fP \fBoperator ValueType\fP () const"
.br
.RI "get a value (implicit) "
.ti -1c
.RI "\fBbinary_t\fP & \fBget_binary\fP ()"
.br
.RI "get a binary value "
.ti -1c
.RI "const \fBbinary_t\fP & \fBget_binary\fP () const"
.br
.RI "get a binary value "
.in -1c
.SS "constructors and destructors"
Constructors of class \fBbasic_json\fP, copy/move constructor, copy assignment, static functions creating objects, and the destructor\&. 
.in +1c
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbinary\fP (const typename binary_t::container_type &init)"
.br
.RI "explicitly create a binary array (without subtype) "
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbinary\fP (const typename binary_t::container_type &init, typename binary_t::subtype_type subtype)"
.br
.RI "explicitly create a binary array (with subtype) "
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbinary\fP (typename binary_t::container_type &&init)"
.br
.RI "explicitly create a binary array "
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbinary\fP (typename binary_t::container_type &&init, typename binary_t::subtype_type subtype)"
.br
.RI "explicitly create a binary array (with subtype) "
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBarray\fP (\fBinitializer_list_t\fP init={})"
.br
.RI "explicitly create an array from an initializer list "
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBobject\fP (\fBinitializer_list_t\fP init={})"
.br
.RI "explicitly create an object from an initializer list "
.ti -1c
.RI "\fBbasic_json\fP (const \fBvalue_t\fP v)"
.br
.RI "create an empty value with a given type "
.ti -1c
.RI "\fBbasic_json\fP (std::nullptr_t=nullptr) noexcept"
.br
.RI "create a null object "
.ti -1c
.RI "template<typename CompatibleType, typename U = detail::uncvref_t<CompatibleType>, \fBdetail::enable_if_t\fP< !\fBdetail::is_basic_json\fP< U >\fB::value\fP &&\fBdetail::is_compatible_type\fP< basic_json_t, U >\fB::value\fP, int > = 0> \fBbasic_json\fP (CompatibleType &&val) noexcept(noexcept(//NOLINT(bugprone\-forwarding\-\fBreference\fP\-overload, bugprone\-\fBexception\fP\-escape) JSONSerializer< U >::to_json(std::declval< basic_json_t & >(), std::forward< CompatibleType >(val))))"
.br
.RI "create a JSON value from compatible types "
.ti -1c
.RI "template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP &&!std::is_same< \fBbasic_json\fP, BasicJsonType >\fB::value\fP, int > = 0> \fBbasic_json\fP (const BasicJsonType &val)"
.br
.RI "create a JSON value from an existing one "
.ti -1c
.RI "\fBbasic_json\fP (\fBinitializer_list_t\fP init, bool type_deduction=true, \fBvalue_t\fP manual_type=value_t::array)"
.br
.RI "create a container (array or object) from an initializer list "
.ti -1c
.RI "\fBbasic_json\fP (\fBsize_type\fP cnt, const \fBbasic_json\fP &val)"
.br
.RI "construct an array with count copies of given value "
.ti -1c
.RI "template<class InputIT, typename std::enable_if< std::is_same< InputIT, typename basic_json_t::iterator >\fB::value\fP||std::is_same< InputIT, typename basic_json_t::const_iterator >\fB::value\fP, int >\fB::type\fP = 0> \fBbasic_json\fP (InputIT first, InputIT last)"
.br
.RI "construct a JSON container given an iterator range "
.ti -1c
.RI "template<typename JsonRef, \fBdetail::enable_if_t\fP< \fBdetail::conjunction\fP< \fBdetail::is_json_ref\fP< JsonRef >, std::is_same< typename JsonRef::value_type, \fBbasic_json\fP > >\fB::value\fP, int > = 0> \fBbasic_json\fP (const JsonRef &ref)"
.br
.ti -1c
.RI "\fBbasic_json\fP (const \fBbasic_json\fP &other)"
.br
.RI "copy constructor "
.ti -1c
.RI "\fBbasic_json\fP (\fBbasic_json\fP &&other) noexcept"
.br
.RI "move constructor "
.ti -1c
.RI "\fBbasic_json\fP & \fBoperator=\fP (\fBbasic_json\fP other) noexcept(std::is_nothrow_move_constructible< \fBvalue_t\fP >\fB::value\fP &&std::is_nothrow_move_assignable< \fBvalue_t\fP >\fB::value\fP &&std::is_nothrow_move_constructible< json_value >\fB::value\fP &&std::is_nothrow_move_assignable< json_value >\fB::value\fP &&std::is_nothrow_move_assignable< json_base_class_t >\fB::value\fP)"
.br
.RI "copy assignment "
.ti -1c
.RI "\fB~basic_json\fP () noexcept"
.br
.RI "destructor "
.in -1c
.SS "iterators"

.in +1c
.ti -1c
.RI "static iteration_proxy< \fBiterator\fP > \fBiterator_wrapper\fP (\fBreference\fP ref) noexcept"
.br
.RI "wrapper to access iterator member functions in range-based for "
.ti -1c
.RI "static iteration_proxy< \fBconst_iterator\fP > \fBiterator_wrapper\fP (\fBconst_reference\fP ref) noexcept"
.br
.RI "wrapper to access iterator member functions in range-based for "
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.RI "returns an iterator to the first element "
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.RI "returns an iterator to the first element "
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.RI "returns a const iterator to the first element "
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.RI "returns an iterator to one past the last element "
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.RI "returns an iterator to one past the last element "
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.RI "returns an iterator to one past the last element "
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.RI "returns an iterator to the reverse-beginning "
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.RI "returns an iterator to the reverse-beginning "
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.RI "returns an iterator to the reverse-end "
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.RI "returns an iterator to the reverse-end "
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.RI "returns a const reverse iterator to the last element "
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.RI "returns a const reverse iterator to one before the first "
.ti -1c
.RI "iteration_proxy< \fBiterator\fP > \fBitems\fP () noexcept"
.br
.RI "helper to access iterator member functions in range-based for "
.ti -1c
.RI "iteration_proxy< \fBconst_iterator\fP > \fBitems\fP () const noexcept"
.br
.RI "helper to access iterator member functions in range-based for "
.in -1c
.SS "binary serialization/deserialization support"

.in +1c
.ti -1c
.RI "static std::vector< std::uint8_t > \fBto_cbor\fP (const \fBbasic_json\fP &j)"
.br
.RI "create a CBOR serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_cbor\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< std::uint8_t > o)"
.br
.RI "create a CBOR serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_cbor\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< char > o)"
.br
.RI "create a CBOR serialization of a given JSON value "
.ti -1c
.RI "static std::vector< std::uint8_t > \fBto_msgpack\fP (const \fBbasic_json\fP &j)"
.br
.RI "create a MessagePack serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_msgpack\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< std::uint8_t > o)"
.br
.RI "create a MessagePack serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_msgpack\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< char > o)"
.br
.RI "create a MessagePack serialization of a given JSON value "
.ti -1c
.RI "static std::vector< std::uint8_t > \fBto_ubjson\fP (const \fBbasic_json\fP &j, const bool use_size=false, const bool use_type=false)"
.br
.RI "create a UBJSON serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_ubjson\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< std::uint8_t > o, const bool use_size=false, const bool use_type=false)"
.br
.RI "create a UBJSON serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_ubjson\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< char > o, const bool use_size=false, const bool use_type=false)"
.br
.RI "create a UBJSON serialization of a given JSON value "
.ti -1c
.RI "static std::vector< std::uint8_t > \fBto_bjdata\fP (const \fBbasic_json\fP &j, const bool use_size=false, const bool use_type=false, const \fBbjdata_version_t\fP version=bjdata_version_t::draft2)"
.br
.RI "create a BJData serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_bjdata\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< std::uint8_t > o, const bool use_size=false, const bool use_type=false, const \fBbjdata_version_t\fP version=bjdata_version_t::draft2)"
.br
.RI "create a BJData serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_bjdata\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< char > o, const bool use_size=false, const bool use_type=false, const \fBbjdata_version_t\fP version=bjdata_version_t::draft2)"
.br
.RI "create a BJData serialization of a given JSON value "
.ti -1c
.RI "static std::vector< std::uint8_t > \fBto_bson\fP (const \fBbasic_json\fP &j)"
.br
.RI "create a BSON serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_bson\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< std::uint8_t > o)"
.br
.RI "create a BSON serialization of a given JSON value "
.ti -1c
.RI "static void \fBto_bson\fP (const \fBbasic_json\fP &j, \fBdetail::output_adapter\fP< char > o)"
.br
.RI "create a BSON serialization of a given JSON value "
.ti -1c
.RI "template<typename InputType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_cbor\fP (InputType &&i, const bool strict=true, const bool allow_exceptions=true, const \fBcbor_tag_handler_t\fP tag_handler=cbor_tag_handler_t::error)"
.br
.RI "create a JSON value from an input in CBOR format "
.ti -1c
.RI "template<typename IteratorType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_cbor\fP (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true, const \fBcbor_tag_handler_t\fP tag_handler=cbor_tag_handler_t::error)"
.br
.RI "create a JSON value from an input in CBOR format "
.ti -1c
.RI "template<typename T> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_cbor\fP (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true, const \fBcbor_tag_handler_t\fP tag_handler=cbor_tag_handler_t::error)"
.br
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_cbor\fP (\fBdetail::span_input_adapter\fP &&i, const bool strict=true, const bool allow_exceptions=true, const \fBcbor_tag_handler_t\fP tag_handler=cbor_tag_handler_t::error)"
.br
.ti -1c
.RI "template<typename InputType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_msgpack\fP (InputType &&i, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in MessagePack format "
.ti -1c
.RI "template<typename IteratorType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_msgpack\fP (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in MessagePack format "
.ti -1c
.RI "template<typename T> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_msgpack\fP (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)"
.br
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_msgpack\fP (\fBdetail::span_input_adapter\fP &&i, const bool strict=true, const bool allow_exceptions=true)"
.br
.ti -1c
.RI "template<typename InputType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_ubjson\fP (InputType &&i, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in UBJSON format "
.ti -1c
.RI "template<typename IteratorType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_ubjson\fP (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in UBJSON format "
.ti -1c
.RI "template<typename T> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_ubjson\fP (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)"
.br
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_ubjson\fP (\fBdetail::span_input_adapter\fP &&i, const bool strict=true, const bool allow_exceptions=true)"
.br
.ti -1c
.RI "template<typename InputType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_bjdata\fP (InputType &&i, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in BJData format "
.ti -1c
.RI "template<typename IteratorType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_bjdata\fP (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in BJData format "
.ti -1c
.RI "template<typename InputType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_bson\fP (InputType &&i, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in BSON format "
.ti -1c
.RI "template<typename IteratorType> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_bson\fP (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)"
.br
.RI "create a JSON value from an input in BSON format "
.ti -1c
.RI "template<typename T> static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_bson\fP (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)"
.br
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBfrom_bson\fP (\fBdetail::span_input_adapter\fP &&i, const bool strict=true, const bool allow_exceptions=true)"
.br
.in -1c
.SS "JSON Patch functions"

.in +1c
.ti -1c
.RI "static \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBdiff\fP (const \fBbasic_json\fP &source, const \fBbasic_json\fP &target, const \fBstring_t\fP &path='')"
.br
.RI "creates a diff as a JSON patch "
.ti -1c
.RI "void \fBpatch_inplace\fP (const \fBbasic_json\fP &json_patch)"
.br
.RI "applies a JSON patch in-place without copying the object "
.ti -1c
.RI "\fBbasic_json\fP \fBpatch\fP (const \fBbasic_json\fP &json_patch) const"
.br
.RI "applies a JSON patch to a copy of the current object "
.in -1c
.SS "object inspection"
Functions to inspect the type of a JSON value\&. 
.in +1c
.ti -1c
.RI "\fBstring_t\fP \fBdump\fP (const int indent=\-1, const char indent_char=' ', const bool ensure_ascii=false, const \fBerror_handler_t\fP error_handler=error_handler_t::strict) const"
.br
.RI "serialization "
.ti -1c
.RI "constexpr \fBvalue_t\fP \fBtype\fP () const noexcept"
.br
.RI "return the type of the JSON value (explicit) "
.ti -1c
.RI "constexpr bool \fBis_primitive\fP () const noexcept"
.br
.RI "return whether type is primitive "
.ti -1c
.RI "constexpr bool \fBis_structured\fP () const noexcept"
.br
.RI "return whether type is structured "
.ti -1c
.RI "constexpr bool \fBis_null\fP () const noexcept"
.br
.RI "return whether value is null "
.ti -1c
.RI "constexpr bool \fBis_boolean\fP () const noexcept"
.br
.RI "return whether value is a boolean "
.ti -1c
.RI "constexpr bool \fBis_number\fP () const noexcept"
.br
.RI "return whether value is a number "
.ti -1c
.RI "constexpr bool \fBis_number_integer\fP () const noexcept"
.br
.RI "return whether value is an integer number "
.ti -1c
.RI "constexpr bool \fBis_number_unsigned\fP () const noexcept"
.br
.RI "return whether value is an unsigned integer number "
.ti -1c
.RI "constexpr bool \fBis_number_float\fP () const noexcept"
.br
.RI "return whether value is a floating-point number "
.ti -1c
.RI "constexpr bool \fBis_object\fP () const noexcept"
.br
.RI "return whether value is an object "
.ti -1c
.RI "constexpr bool \fBis_array\fP () const noexcept"
.br
.RI "return whether value is an array "
.ti -1c
.RI "constexpr bool \fBis_string\fP () const noexcept"
.br
.RI "return whether value is a string "
.ti -1c
.RI "constexpr bool \fBis_binary\fP () const noexcept"
.br
.RI "return whether value is a binary array "
.ti -1c
.RI "constexpr bool \fBis_discarded\fP () const noexcept"
.br
.RI "return whether value is discarded "
.ti -1c
.RI "constexpr \fBoperator value_t\fP () const noexcept"
.br
.RI "return the type of the JSON value (implicit) "
.in -1c
.SS "lookup"

.in +1c
.ti -1c
.RI "\fBiterator\fP \fBfind\fP (const typename object_t::key_type &key)"
.br
.RI "find an element in a JSON object "
.ti -1c
.RI "\fBconst_iterator\fP \fBfind\fP (const typename object_t::key_type &key) const"
.br
.RI "find an element in a JSON object "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBiterator\fP \fBfind\fP (KeyType &&key)"
.br
.RI "find an element in a JSON object "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBconst_iterator\fP \fBfind\fP (KeyType &&key) const"
.br
.RI "find an element in a JSON object "
.ti -1c
.RI "\fBsize_type\fP \fBcount\fP (const typename object_t::key_type &key) const"
.br
.RI "returns the number of occurrences of a key in a JSON object "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBsize_type\fP \fBcount\fP (KeyType &&key) const"
.br
.RI "returns the number of occurrences of a key in a JSON object "
.ti -1c
.RI "bool \fBcontains\fP (const typename object_t::key_type &key) const"
.br
.RI "check the existence of an element in a JSON object "
.ti -1c
.RI "template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> bool \fBcontains\fP (KeyType &&key) const"
.br
.RI "check the existence of an element in a JSON object "
.ti -1c
.RI "bool \fBcontains\fP (const \fBjson_pointer\fP &ptr) const"
.br
.RI "check the existence of an element in a JSON object given a JSON pointer "
.ti -1c
.RI "template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> bool \fBcontains\fP (const typename ::nlohmann::json_pointer< BasicJsonType > &ptr) const"
.br
.in -1c
.SS "capacity"

.in +1c
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.RI "checks whether the container is empty\&. "
.ti -1c
.RI "\fBsize_type\fP \fBsize\fP () const noexcept"
.br
.RI "returns the number of elements "
.ti -1c
.RI "\fBsize_type\fP \fBmax_size\fP () const noexcept"
.br
.RI "returns the maximum possible number of elements "
.in -1c
.SS "JSON Pointer functions"

.in +1c
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (const \fBjson_pointer\fP &ptr)"
.br
.RI "access specified element via JSON Pointer "
.ti -1c
.RI "template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBreference\fP \fBoperator[]\fP (const ::nlohmann::json_pointer< BasicJsonType > &ptr)"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBoperator[]\fP (const \fBjson_pointer\fP &ptr) const"
.br
.RI "access specified element via JSON Pointer "
.ti -1c
.RI "template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBoperator[]\fP (const ::nlohmann::json_pointer< BasicJsonType > &ptr) const"
.br
.ti -1c
.RI "\fBreference\fP \fBat\fP (const \fBjson_pointer\fP &ptr)"
.br
.RI "access specified element via JSON Pointer "
.ti -1c
.RI "template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBreference\fP \fBat\fP (const ::nlohmann::json_pointer< BasicJsonType > &ptr)"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBat\fP (const \fBjson_pointer\fP &ptr) const"
.br
.RI "access specified element via JSON Pointer "
.ti -1c
.RI "template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBat\fP (const ::nlohmann::json_pointer< BasicJsonType > &ptr) const"
.br
.ti -1c
.RI "\fBbasic_json\fP \fBflatten\fP () const"
.br
.RI "return flattened JSON value "
.ti -1c
.RI "\fBbasic_json\fP \fBunflatten\fP () const"
.br
.RI "unflatten a previously flattened JSON value "
.in -1c
.SS "JSON Merge Patch functions"

.in +1c
.ti -1c
.RI "void \fBmerge_patch\fP (const \fBbasic_json\fP &apply_patch)"
.br
.RI "applies a JSON Merge Patch "
.in -1c
.SH "상세한 설명"
.PP 

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void>
.br
class basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >"namespace for Niels Lohmann 

a class to store JSON values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/

.PP
https://github.com/nlohmann 
.RE
.PP
\fBSince\fP
.RS 4
version 1\&.0\&.0
.RE
.PP
a class to store JSON values

.PP
\fBSince\fP
.RS 4
version 1\&.0\&.0 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20201\fP 번째 라인에서 정의되었습니다\&.
.SH "멤버 타입정의 문서화"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::allocator_type = AllocatorType<\fBbasic_json\fP>"

.PP
the allocator type 
.PP
\fBjson\&.hpp\fP 파일의 \fB20327\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::array_t = ArrayType<\fBbasic_json\fP, AllocatorType<\fBbasic_json\fP>>"

.PP
a type for an array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/array_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20448\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::binary_t = nlohmann::byte_container_with_subtype<BinaryType>"

.PP
a type for a packed binary type 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/binary_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20472\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::bjdata_version_t = \fBdetail::bjdata_version_t\fP"

.PP
how to encode BJData 
.PP
\fBjson\&.hpp\fP 파일의 \fB20279\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::boolean_t = BooleanType"

.PP
a type for a boolean 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/boolean_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20456\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::cbor_tag_handler_t = \fBdetail::cbor_tag_handler_t\fP"

.PP
how to treat CBOR tags 
.PP
\fBjson\&.hpp\fP 파일의 \fB20277\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::const_iterator = \fBiter_impl\fP<const \fBbasic_json\fP>"

.PP
a const iterator for a \fBbasic_json\fP container 
.PP
\fBjson\&.hpp\fP 파일의 \fB20337\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::const_pointer = typename std::allocator_traits<\fBallocator_type\fP>::const_pointer"

.PP
the type of an element const pointer 
.PP
\fBjson\&.hpp\fP 파일의 \fB20332\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::const_reference = const \fBvalue_type\fP&"

.PP
the type of an element const reference 
.PP
\fBjson\&.hpp\fP 파일의 \fB20319\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::const_reverse_iterator = json_reverse_iterator<typename \fBbasic_json::const_iterator\fP>"

.PP
a const reverse iterator for a \fBbasic_json\fP container 
.PP
\fBjson\&.hpp\fP 파일의 \fB20341\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::default_object_comparator_t = std::less<StringType>"

.PP
default object key comparator type The actual object key comparator type (\fBobject_comparator_t\fP) may be different\&. 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/default_object_comparator_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20435\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::difference_type = std::ptrdiff_t"

.PP
a type to represent differences between iterators 
.PP
\fBjson\&.hpp\fP 파일의 \fB20322\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::error_handler_t = \fBdetail::error_handler_t\fP"

.PP
how to treat decoding errors 
.PP
\fBjson\&.hpp\fP 파일의 \fB20275\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::exception = \fBdetail::exception\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20295\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::initializer_list_t = std::initializer_list<\fBdetail::json_ref\fP<\fBbasic_json\fP>>"

.PP
helper type for initializer lists of \fBbasic_json\fP values 
.PP
\fBjson\&.hpp\fP 파일의 \fB20281\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::input_format_t = \fBdetail::input_format_t\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20283\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::invalid_iterator = \fBdetail::invalid_iterator\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20297\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::iterator = \fBiter_impl\fP<\fBbasic_json\fP>"

.PP
an iterator for a \fBbasic_json\fP container 
.PP
\fBjson\&.hpp\fP 파일의 \fB20335\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::json_pointer\fP = ::nlohmann::json_pointer<StringType>"

.PP
JSON Pointer, see \fBnlohmann::json_pointer\fP 
.PP
\fBjson\&.hpp\fP 파일의 \fB20271\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::json_sax_t = \fBjson_sax\fP<\fBbasic_json\fP>"

.PP
SAX interface type, see \fBnlohmann::json_sax\fP 
.PP
\fBjson\&.hpp\fP 파일의 \fB20285\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T, typename SFINAE> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::json_serializer = JSONSerializer<T, SFINAE>"

.PP
\fBjson\&.hpp\fP 파일의 \fB20273\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::number_float_t = NumberFloatType"

.PP
a type for a number (floating-point) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/number_float_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20468\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::number_integer_t = NumberIntegerType"

.PP
a type for a number (integer) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/number_integer_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20460\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::number_unsigned_t = NumberUnsignedType"

.PP
a type for a number (unsigned) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/number_unsigned_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20464\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::object_comparator_t = \fBdetail::actual_object_comparator_t\fP<\fBbasic_json\fP>"

.PP
object key comparator type 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/object_comparator_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20476\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::object_t"
\fB초기값:\fP
.nf
 ObjectType<StringType,
          basic_json,
          default_object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>
.PP
.fi

.PP
a type for an object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/object_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20440\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::other_error = \fBdetail::other_error\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20300\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::out_of_range = \fBdetail::out_of_range\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20299\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::parse_error = \fBdetail::parse_error\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20296\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::parse_event_t = \fBdetail::parse_event_t\fP"

.PP
parser event types 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/parse_event_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20905\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::parser_callback_t = \fBdetail::parser_callback_t\fP<\fBbasic_json\fP>"

.PP
per-element parser callback type 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/parser_callback_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20909\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::pointer = typename std::allocator_traits<\fBallocator_type\fP>::pointer"

.PP
the type of an element pointer 
.PP
\fBjson\&.hpp\fP 파일의 \fB20330\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::reference = \fBvalue_type\fP&"

.PP
the type of an element reference 
.PP
\fBjson\&.hpp\fP 파일의 \fB20317\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::reverse_iterator = json_reverse_iterator<typename \fBbasic_json::iterator\fP>"

.PP
a reverse iterator for a \fBbasic_json\fP container 
.PP
\fBjson\&.hpp\fP 파일의 \fB20339\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::size_type = std::size_t"

.PP
a type to represent container sizes 
.PP
\fBjson\&.hpp\fP 파일의 \fB20324\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::string_t = StringType"

.PP
a type for a string 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/string_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20452\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::type_error = \fBdetail::type_error\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20298\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value_t = \fBdetail::value_t\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20269\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> using \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value_type = \fBbasic_json\fP"

.PP
the type of elements in a \fBbasic_json\fP container 
.PP
\fBjson\&.hpp\fP 파일의 \fB20314\fP 번째 라인에서 정의되었습니다\&.
.SH "생성자 & 소멸자 문서화"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (const \fBvalue_t\fP v)\fR [inline]\fP"

.PP
create an empty value with a given type 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20922\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (std::nullptr_t  = \fRnullptr\fP)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
create a null object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20930\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename CompatibleType, typename U = detail::uncvref_t<CompatibleType>, \fBdetail::enable_if_t\fP< !\fBdetail::is_basic_json\fP< U >\fB::value\fP &&\fBdetail::is_compatible_type\fP< basic_json_t, U >\fB::value\fP, int > = 0> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (CompatibleType && val)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
create a JSON value from compatible types 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20942\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP &&!std::is_same< \fBbasic_json\fP, BasicJsonType >\fB::value\fP, int > = 0> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (const BasicJsonType & val)\fR [inline]\fP"

.PP
create a JSON value from an existing one 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20956\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (\fBinitializer_list_t\fP init, bool type_deduction = \fRtrue\fP, \fBvalue_t\fP manual_type = \fRvalue_t::array\fP)\fR [inline]\fP"

.PP
create a container (array or object) from an initializer list 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21014\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (\fBsize_type\fP cnt, const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & val)\fR [inline]\fP"

.PP
construct an array with count copies of given value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21132\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class InputIT, typename std::enable_if< std::is_same< InputIT, typename basic_json_t::iterator >\fB::value\fP||std::is_same< InputIT, typename basic_json_t::const_iterator >\fB::value\fP, int >\fB::type\fP = 0> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (InputIT first, InputIT last)\fR [inline]\fP"

.PP
construct a JSON container given an iterator range 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21144\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename JsonRef, \fBdetail::enable_if_t\fP< \fBdetail::conjunction\fP< \fBdetail::is_json_ref\fP< JsonRef >, std::is_same< typename JsonRef::value_type, \fBbasic_json\fP > >\fB::value\fP, int > = 0> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (const JsonRef & ref)\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB21253\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & other)\fR [inline]\fP"

.PP
copy constructor 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21257\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >\fB::basic_json\fP (\fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > && other)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
move constructor 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21330\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::~\fBbasic_json\fP ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
destructor 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/~basic_json/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21385\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::~\fBdata\fP ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24358\fP 번째 라인에서 정의되었습니다\&.
.SH "멤버 함수 문서화"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::array (\fBinitializer_list_t\fP init = \fR{}\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
explicitly create an array from an initializer list 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/array/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21117\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (const ::nlohmann::json_pointer< BasicJsonType > & ptr)\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24817\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (const ::nlohmann::json_pointer< BasicJsonType > & ptr) const\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24831\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (const \fBjson_pointer\fP & ptr)\fR [inline]\fP"

.PP
access specified element via JSON Pointer 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24810\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (const \fBjson_pointer\fP & ptr) const\fR [inline]\fP"

.PP
access specified element via JSON Pointer 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24824\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (const typename object_t::key_type & key)\fR [inline]\fP"

.PP
access specified object element with bounds checking 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22115\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (const typename object_t::key_type & key) const\fR [inline]\fP"

.PP
access specified object element with bounds checking 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22153\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (KeyType && key)\fR [inline]\fP"

.PP
access specified object element with bounds checking 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22135\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (KeyType && key) const\fR [inline]\fP"

.PP
access specified object element with bounds checking 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22173\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (\fBsize_type\fP idx)\fR [inline]\fP"

.PP
access specified array element with bounds checking 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22069\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::at (\fBsize_type\fP idx) const\fR [inline]\fP"

.PP
access specified array element with bounds checking 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/at/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22092\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::back ()\fR [inline]\fP"

.PP
access the last element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/back/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22541\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::back () const\fR [inline]\fP"

.PP
access the last element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/back/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22550\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::begin () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to the first element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/begin/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22910\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::begin ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to the first element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/begin/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22901\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::binary (const typename binary_t::container_type & init)\fR [inline]\fP, \fR [static]\fP"

.PP
explicitly create a binary array (without subtype) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/binary/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21073\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::binary (const typename binary_t::container_type & init, typename binary_t::subtype_type subtype)\fR [inline]\fP, \fR [static]\fP"

.PP
explicitly create a binary array (with subtype) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/binary/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21084\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::binary (typename binary_t::container_type && init)\fR [inline]\fP, \fR [static]\fP"

.PP
explicitly create a binary array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/binary/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21095\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::binary (typename binary_t::container_type && init, typename binary_t::subtype_type subtype)\fR [inline]\fP, \fR [static]\fP"

.PP
explicitly create a binary array (with subtype) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/binary/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21106\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::cbegin () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns a const iterator to the first element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/cbegin/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22917\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::cend () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to one past the last element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/cend/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22942\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::clear ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
clears the contents 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/clear/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23160\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::contains (const \fBjson_pointer\fP & ptr) const\fR [inline]\fP"

.PP
check the existence of an element in a JSON object given a JSON pointer 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/contains/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22878\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::contains (const typename ::nlohmann::json_pointer< BasicJsonType > & ptr) const\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB22885\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::contains (const typename object_t::key_type & key) const\fR [inline]\fP"

.PP
check the existence of an element in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/contains/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22862\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::contains (KeyType && key) const\fR [inline]\fP"

.PP
check the existence of an element in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/contains/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22871\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBsize_type\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::count (const typename object_t::key_type & key) const\fR [inline]\fP"

.PP
returns the number of occurrences of a key in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/count/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22844\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBsize_type\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::count (KeyType && key) const\fR [inline]\fP"

.PP
returns the number of occurrences of a key in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/count/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22854\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reverse_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::crbegin () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns a const reverse iterator to the last element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/crbegin/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22979\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reverse_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::crend () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns a const reverse iterator to one before the first 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/crend/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22986\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::data ()\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::data (const data & )\fR [delete]\fP, \fR [noexcept]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::data (const \fBvalue_t\fP v)\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24341\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::data (data && )\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::data (\fBsize_type\fP cnt, const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & val)\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24346\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::diff (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & source, const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & target, const \fBstring_t\fP & path = \fR''\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
creates a diff as a JSON patch 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/diff/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB25144\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBstring_t\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::dump (const int indent = \fR\-1\fP, const char indent_char = \fR' '\fP, const bool ensure_ascii = \fRfalse\fP, const \fBerror_handler_t\fP error_handler = \fRerror_handler_t::strict\fP) const\fR [inline]\fP"

.PP
serialization 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/dump/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21403\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class\&.\&.\&. Args> std::pair< \fBiterator\fP, bool > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::emplace (Args &&\&.\&.\&. args)\fR [inline]\fP"

.PP
add an object to an object if key does not exist 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/emplace/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23367\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class\&.\&.\&. Args> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::emplace_back (Args &&\&.\&.\&. args)\fR [inline]\fP"

.PP
add an object to an array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/emplace_back/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23342\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::empty () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
checks whether the container is empty\&. 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/empty/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23039\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::end () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to one past the last element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/end/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22935\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::end ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to one past the last element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/end/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22926\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::erase (const \fBsize_type\fP idx)\fR [inline]\fP"

.PP
remove element from a JSON array given an index 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/erase/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22755\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBsize_type\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::erase (const typename object_t::key_type & key)\fR [inline]\fP"

.PP
remove element from a JSON object given a key 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/erase/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22737\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class IteratorType, \fBdetail::enable_if_t\fP< std::is_same< IteratorType, typename basic_json_t::iterator >\fB::value\fP||std::is_same< IteratorType, typename basic_json_t::const_iterator >\fB::value\fP, int > = 0> IteratorType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::erase (IteratorType first, IteratorType last)\fR [inline]\fP"

.PP
remove elements given an iterator range 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/erase/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22632\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class IteratorType, \fBdetail::enable_if_t\fP< std::is_same< IteratorType, typename basic_json_t::iterator >\fB::value\fP||std::is_same< IteratorType, typename basic_json_t::const_iterator >\fB::value\fP, int > = 0> IteratorType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::erase (IteratorType pos)\fR [inline]\fP"

.PP
remove element given an iterator 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/erase/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22562\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBsize_type\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::erase (KeyType && key)\fR [inline]\fP"

.PP
remove element from a JSON object given a key 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/erase/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22748\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::find (const typename object_t::key_type & key)\fR [inline]\fP"

.PP
find an element in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/find/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22784\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::find (const typename object_t::key_type & key) const\fR [inline]\fP"

.PP
find an element in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/find/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22798\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::find (KeyType && key)\fR [inline]\fP"

.PP
find an element in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/find/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22814\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBconst_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::find (KeyType && key) const\fR [inline]\fP"

.PP
find an element in a JSON object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/find/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22830\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::flatten () const\fR [inline]\fP"

.PP
return flattened JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/flatten/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24838\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename InputType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_bjdata (InputType && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in BJData format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_bjdata/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24692\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename IteratorType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_bjdata (IteratorType first, IteratorType last, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in BJData format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_bjdata/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24707\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_bson (const T * ptr, std::size_t len, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24751\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_bson (\fBdetail::span_input_adapter\fP && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24760\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename InputType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_bson (InputType && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in BSON format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_bson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24722\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename IteratorType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_bson (IteratorType first, IteratorType last, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in BSON format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_bson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24737\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_cbor (const T * ptr, std::size_t len, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP, const \fBcbor_tag_handler_t\fP tag_handler = \fRcbor_tag_handler_t::error\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24557\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_cbor (\fBdetail::span_input_adapter\fP && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP, const \fBcbor_tag_handler_t\fP tag_handler = \fRcbor_tag_handler_t::error\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24567\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename InputType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_cbor (InputType && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP, const \fBcbor_tag_handler_t\fP tag_handler = \fRcbor_tag_handler_t::error\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in CBOR format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_cbor/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24526\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename IteratorType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_cbor (IteratorType first, IteratorType last, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP, const \fBcbor_tag_handler_t\fP tag_handler = \fRcbor_tag_handler_t::error\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in CBOR format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_cbor/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24542\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_msgpack (const T * ptr, std::size_t len, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24613\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_msgpack (\fBdetail::span_input_adapter\fP && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24622\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename InputType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_msgpack (InputType && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in MessagePack format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_msgpack/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24584\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename IteratorType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_msgpack (IteratorType first, IteratorType last, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in MessagePack format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_msgpack/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24599\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_ubjson (const T * ptr, std::size_t len, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24667\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_ubjson (\fBdetail::span_input_adapter\fP && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24676\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename InputType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_ubjson (InputType && i, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in UBJSON format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_ubjson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24638\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename IteratorType> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::from_ubjson (IteratorType first, IteratorType last, const bool strict = \fRtrue\fP, const bool allow_exceptions = \fRtrue\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a JSON value from an input in UBJSON format 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/from_ubjson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24653\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::front ()\fR [inline]\fP"

.PP
access the first element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/front/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22527\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::front () const\fR [inline]\fP"

.PP
access the first element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/front/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22534\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>> auto \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get () const \-> decltype(std::declval<const basic_json_t&>()\&.template get_impl<ValueType>(\fBdetail::priority_tag\fP<4> {}))
    \fR [inline]\fP, \fR [noexcept]\fP"

.PP
get a (pointer) value (explicit) Performs explicit type conversion between the JSON value and a compatible value if required\&.

.PP
.IP "\(bu" 2
If the requested type is a pointer to the internally stored JSON value that pointer is returned\&. No copies are made\&.
.IP "\(bu" 2
If the requested type is the current \fBbasic_json\fP, or a different \fBbasic_json\fP convertible from the current \fBbasic_json\fP\&.
.IP "\(bu" 2
Otherwise the value is converted by calling the \fBjson_serializer<ValueType>\fP \fRfrom_json()\fP method\&.
.PP

.PP
\fB템플릿 파라메터\fP
.RS 4
\fIValueTypeCV\fP the provided value type 
.br
\fIValueType\fP the returned value type
.RE
.PP
\fB반환값\fP
.RS 4
copy of the JSON value, converted to 
.RE
.PP
\fB템플릿 파라메터\fP
.RS 4
\fIValueType\fP if necessary
.RE
.PP
\fB예외\fP
.RS 4
\fIwhat\fP \fBjson_serializer<ValueType>\fP \fRfrom_json()\fP method throws if conversion is required
.RE
.PP
\fBSince\fP
.RS 4
version 2\&.1\&.0 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21875\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename PointerType, typename std::enable_if< std::is_pointer< PointerType >\fB::value\fP, int >\fB::type\fP = 0> auto \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get () \-> decltype(std::declval<basic_json_t&>()\&.template \fBget_ptr\fP<PointerType>())
    \fR [inline]\fP, \fR [noexcept]\fP"

.PP
get a pointer value (explicit) Explicit pointer access to the internally stored JSON value\&. No copies are made\&.

.PP
\fB경고\fP
.RS 4
The pointer becomes invalid if the underlying JSON object changes\&.
.RE
.PP
\fB템플릿 파라메터\fP
.RS 4
\fIPointerType\fP pointer type; must be a pointer to \fBarray_t\fP, \fBobject_t\fP, \fBstring_t\fP, \fBboolean_t\fP, \fBnumber_integer_t\fP, \fBnumber_unsigned_t\fP, or \fBnumber_float_t\fP\&.
.RE
.PP
\fB반환값\fP
.RS 4
pointer to the internally stored JSON value if the requested pointer type \fIPointerType\fP fits to the JSON value; \fRnullptr\fP otherwise
.RE
.PP
@complexity Constant\&.

.PP
@liveexample{The example below shows how pointers to internal values of a JSON value can be requested\&. Note that no type conversions are made and a \fRnullptr\fP is returned if the value and the requested pointer type does not match\&.,get__PointerType}

.PP
\fB참고\fP
.RS 4
see \fBget_ptr()\fP for explicit pointer-member access
.RE
.PP
\fBSince\fP
.RS 4
version 1\&.0\&.0 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21916\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBallocator_type\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_allocator ()\fR [inline]\fP, \fR [static]\fP"

.PP
returns the allocator associated with the container 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_allocator/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20347\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbinary_t\fP & \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_binary ()\fR [inline]\fP"

.PP
get a binary value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_binary/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22035\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> const \fBbinary_t\fP & \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_binary () const\fR [inline]\fP"

.PP
get a binary value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_binary/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22047\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename PointerType, typename std::enable_if< std::is_pointer< PointerType >\fB::value\fP &&std::is_const< typename std::remove_pointer< PointerType >\fB::type\fP >\fB::value\fP, int >\fB::type\fP = 0> auto \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_ptr () const \-> decltype(std::declval<const basic_json_t&>()\&.get_impl_ptr(std::declval<PointerType>()))
    \fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
get a pointer value (implicit) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_ptr/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21687\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename PointerType, typename std::enable_if< std::is_pointer< PointerType >\fB::value\fP, int >\fB::type\fP = 0> auto \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_ptr () \-> decltype(std::declval<basic_json_t&>()\&.get_impl_ptr(std::declval<PointerType>()))
    \fR [inline]\fP, \fR [noexcept]\fP"

.PP
get a pointer value (implicit) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_ptr/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21676\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename ReferenceType, typename std::enable_if< std::is_reference< ReferenceType >\fB::value\fP, int >\fB::type\fP = 0> ReferenceType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_ref ()\fR [inline]\fP"

.PP
get a reference value (implicit) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_ref/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21965\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename ReferenceType, typename std::enable_if< std::is_reference< ReferenceType >\fB::value\fP &&std::is_const< typename std::remove_reference< ReferenceType >\fB::type\fP >\fB::value\fP, int >\fB::type\fP = 0> ReferenceType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_ref () const\fR [inline]\fP"

.PP
get a reference value (implicit) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_ref/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21976\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T, std::size_t N, typename Array = T (&)[N], \fBdetail::enable_if_t\fP< \fBdetail::has_from_json\fP< basic_json_t, Array >\fB::value\fP, int > = 0> Array \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_to (T(&) v[N]) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB21953\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename ValueType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< ValueType >\fB::value\fP, int > = 0> ValueType & \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_to (ValueType & v) const\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB21942\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename ValueType, \fBdetail::enable_if_t\fP< !\fBdetail::is_basic_json\fP< ValueType >\fB::value\fP &&\fBdetail::has_from_json\fP< basic_json_t, ValueType >\fB::value\fP, int > = 0> ValueType & \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::get_to (ValueType & v) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
get a value (explicit) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/get_to/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21929\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::insert (\fBconst_iterator\fP first, \fBconst_iterator\fP last)\fR [inline]\fP"

.PP
inserts range of elements into object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/insert/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23516\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::insert (\fBconst_iterator\fP pos, \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > && val)\fR [inline]\fP"

.PP
inserts element into array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/insert/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23438\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::insert (\fBconst_iterator\fP pos, const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & val)\fR [inline]\fP"

.PP
inserts element into array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/insert/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23418\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::insert (\fBconst_iterator\fP pos, \fBconst_iterator\fP first, \fBconst_iterator\fP last)\fR [inline]\fP"

.PP
inserts range of elements into array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/insert/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23465\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::insert (\fBconst_iterator\fP pos, \fBinitializer_list_t\fP ilist)\fR [inline]\fP"

.PP
inserts elements from initializer list into array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/insert/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23496\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::insert (\fBconst_iterator\fP pos, \fBsize_type\fP cnt, const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & val)\fR [inline]\fP"

.PP
inserts copies of element into array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/insert/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23445\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename\&.\&.\&. Args> \fBiterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::insert_iterator (\fBconst_iterator\fP pos, Args &&\&.\&.\&. args)\fR [inline]\fP"
Helper for insertion of an iterator 
.PP
\fB주의\fP
.RS 4
: This uses std::distance to support GCC 4\&.8, see https://github.com/nlohmann/json/pull/1257 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23399\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_array () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is an array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_array/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21495\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_binary () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is a binary array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_binary/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21509\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_boolean () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is a boolean 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_boolean/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21453\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_discarded () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is discarded 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_discarded/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21516\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_null () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is null 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_null/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21446\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_number () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is a number 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_number/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21460\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_number_float () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is a floating-point number 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_number_float/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21481\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_number_integer () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is an integer number 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_number_integer/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21467\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_number_unsigned () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is an unsigned integer number 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_number_unsigned/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21474\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_object () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is an object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_object/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21488\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_primitive () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether type is primitive 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_primitive/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21432\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_string () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether value is a string 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_string/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21502\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::is_structured () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return whether type is structured 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/is_structured/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21439\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> iteration_proxy< \fBconst_iterator\fP > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::items () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
helper to access iterator member functions in range-based for 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/items/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23023\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> iteration_proxy< \fBiterator\fP > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::items ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
helper to access iterator member functions in range-based for 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/items/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23016\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> iteration_proxy< \fBconst_iterator\fP > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::iterator_wrapper (\fBconst_reference\fP ref)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"

.PP
wrapper to access iterator member functions in range-based for 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/items/ 
.RE
.PP
\fB잘못된 코드\fP
.RS 4
This function is deprecated since 3\&.1\&.0 and will be removed in version 4\&.0\&.0 of the library\&. Please use \fBitems()\fP instead; that is, replace \fRjson::iterator_wrapper(j)\fP with \fRj\&.items()\fP\&. 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23009\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> iteration_proxy< \fBiterator\fP > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::iterator_wrapper (\fBreference\fP ref)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"

.PP
wrapper to access iterator member functions in range-based for 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/items/ 
.RE
.PP
\fB잘못된 코드\fP
.RS 4
This function is deprecated since 3\&.1\&.0 and will be removed in version 4\&.0\&.0 of the library\&. Please use \fBitems()\fP instead; that is, replace \fRjson::iterator_wrapper(j)\fP with \fRj\&.items()\fP\&. 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22998\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBsize_type\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::max_size () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns the maximum possible number of elements 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/max_size/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23117\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::merge_patch (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & apply_patch)\fR [inline]\fP"

.PP
applies a JSON Merge Patch 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/merge_patch/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB25286\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::meta ()\fR [inline]\fP, \fR [static]\fP"

.PP
returns version information on the library 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/meta/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB20355\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_WARN_UNUSED_RESULT\fP \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::object (\fBinitializer_list_t\fP init = \fR{}\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
explicitly create an object from an initializer list 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/object/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21125\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator \fBvalue_t\fP () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return the type of the JSON value (implicit) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator_value_t/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21523\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename ValueType, typename std::enable_if< \fBdetail::conjunction\fP< \fBdetail::negation\fP< std::is_pointer< ValueType > >, \fBdetail::negation\fP< std::is_same< ValueType, std::nullptr_t > >, \fBdetail::negation\fP< std::is_same< ValueType, \fBdetail::json_ref\fP< \fBbasic_json\fP > > >, \fBdetail::negation\fP< std::is_same< ValueType, typename string_t::value_type > >, \fBdetail::negation\fP< \fBdetail::is_basic_json\fP< ValueType > >, \fBdetail::negation\fP< std::is_same< ValueType, std::initializer_list< typename string_t::value_type > > >, \fBdetail::is_detected_lazy\fP< \fBdetail::get_template_function\fP, const basic_json_t &, ValueType > >\fB::value\fP, int >\fB::type\fP = 0> \fBJSON_EXPLICIT\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator ValueType () const\fR [inline]\fP"

.PP
get a value (implicit) Implicit type conversion between the JSON value and a compatible value\&. The call is realized by calling \fBget() const\fP\&.

.PP
\fB템플릿 파라메터\fP
.RS 4
\fIValueType\fP non-pointer type compatible to the JSON value, for instance \fRint\fP for JSON integer numbers, \fRbool\fP for JSON booleans, or \fRstd::vector\fP types for JSON arrays\&. The character type of \fBstring_t\fP as well as an initializer list of this type is excluded to avoid ambiguities as these types implicitly convert to \fRstd::string\fP\&.
.RE
.PP
\fB반환값\fP
.RS 4
copy of the JSON value, converted to type \fIValueType\fP 
.RE
.PP
\fB예외\fP
.RS 4
\fItype_error\&.302\fP in case passed type \fIValueType\fP is incompatible to the JSON value type (e\&.g\&., the JSON value is of type boolean, but a string is requested); see example below
.RE
.PP
@complexity Linear in the size of the JSON value\&.

.PP
@liveexample{The example below shows several conversions from JSON values to other types\&. There a few things to note: (1) Floating-point numbers can be converted to integers\\, (2) A JSON array can be converted to a standard \fRstd::vector<short>\fP\\, (3) A JSON object can be converted to C++ associative containers such as \fRstd::unordered_map<std::string\\, json>\fP\&.,operator__ValueType}

.PP
\fBSince\fP
.RS 4
version 1\&.0\&.0 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22027\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator+= (\fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > && val)\fR [inline]\fP"

.PP
add an object to an array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator+=/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23246\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator+= (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & val)\fR [inline]\fP"

.PP
add an object to an array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator+=/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23278\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator+= (const typename object_t::value_type & val)\fR [inline]\fP"

.PP
add an object to an object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator+=/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23309\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator+= (\fBinitializer_list_t\fP init)\fR [inline]\fP"

.PP
add an object to an object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator+=/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23333\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP & \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator= (\fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > other)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
copy assignment 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator=/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21356\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBdata\fP & \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator= (const \fBdata\fP & )\fR [delete]\fP, \fR [noexcept]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBdata\fP & \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator= (\fBdata\fP && )\fR [delete]\fP, \fR [noexcept]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (const ::nlohmann::json_pointer< BasicJsonType > & ptr)\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24789\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (const ::nlohmann::json_pointer< BasicJsonType > & ptr) const\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24803\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (const \fBjson_pointer\fP & ptr)\fR [inline]\fP"

.PP
access specified element via JSON Pointer 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24782\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (const \fBjson_pointer\fP & ptr) const\fR [inline]\fP"

.PP
access specified element via JSON Pointer 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24796\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (const typename object_t::key_type & key) const\fR [inline]\fP"

.PP
access specified object element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22272\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (KeyType && key)\fR [inline]\fP"

.PP
access specified object element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22303\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_usable_as_basic_json_key_type\fP< basic_json_t, KeyType >\fB::value\fP, int > = 0> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (KeyType && key) const\fR [inline]\fP"

.PP
access specified object element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22327\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (\fBsize_type\fP idx)\fR [inline]\fP"

.PP
access specified array element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22191\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (\fBsize_type\fP idx) const\fR [inline]\fP"

.PP
access specified array element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22237\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (T * key)\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB22288\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename T> \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (T * key) const\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB22294\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::operator[] (typename object_t::key_type key)\fR [inline]\fP"

.PP
access specified object element 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator%5B%5D/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22250\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::patch (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & json_patch) const\fR [inline]\fP"

.PP
applies a JSON patch to a copy of the current object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/patch/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB25134\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::patch_inplace (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & json_patch)\fR [inline]\fP"

.PP
applies a JSON patch in-place without copying the object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/patch/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24863\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::push_back (\fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > && val)\fR [inline]\fP"

.PP
add an object to an array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/push_back/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23221\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::push_back (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & val)\fR [inline]\fP"

.PP
add an object to an array 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/push_back/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23254\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::push_back (const typename object_t::value_type & val)\fR [inline]\fP"

.PP
add an object to an object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/push_back/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23286\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::push_back (\fBinitializer_list_t\fP init)\fR [inline]\fP"

.PP
add an object to an object 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/push_back/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23317\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reverse_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::rbegin () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to the reverse-beginning 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/rbegin/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22958\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreverse_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::rbegin ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to the reverse-beginning 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/rbegin/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22951\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBconst_reverse_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::rend () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to the reverse-end 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/rend/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22972\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBreverse_iterator\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::rend ()\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns an iterator to the reverse-end 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/rend/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22965\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename SAX> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::sax_parse (\fBdetail::span_input_adapter\fP && i, SAX * sax, \fBinput_format_t\fP format = \fRinput_format_t::json\fP, const bool strict = \fRtrue\fP, const bool ignore_comments = \fRfalse\fP, const bool ignore_trailing_commas = \fRfalse\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
generate SAX events 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/sax_parse/ 
.RE
.PP
\fB잘못된 코드\fP
.RS 4
This function is deprecated since 3\&.8\&.0 and will be removed in version 4\&.0\&.0 of the library\&. Please use sax_parse(ptr, ptr + len) instead\&. 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24258\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_PRIVATE_UNLESS_TESTED\fP \fBconst_reference\fP bool static SAX bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::sax_parse (InputType && i, SAX * sax, \fBinput_format_t\fP format = \fRinput_format_t::json\fP, const bool strict = \fRtrue\fP, const bool ignore_comments = \fRfalse\fP, const bool ignore_trailing_commas = \fRfalse\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB24222\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class IteratorType, class SAX> bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::sax_parse (IteratorType first, IteratorType last, SAX * sax, \fBinput_format_t\fP format = \fRinput_format_t::json\fP, const bool strict = \fRtrue\fP, const bool ignore_comments = \fRfalse\fP, const bool ignore_trailing_commas = \fRfalse\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
generate SAX events 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/sax_parse/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24238\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBsize_type\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::size () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
returns the number of elements 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/size/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23078\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::swap (\fBarray_t\fP & other)\fR [inline]\fP"

.PP
exchanges the values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/swap/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23625\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::swap (\fBbinary_t\fP & other)\fR [inline]\fP"

.PP
exchanges the values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/swap/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23673\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::swap (\fBobject_t\fP & other)\fR [inline]\fP"

.PP
exchanges the values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/swap/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23641\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::swap (\fBreference\fP other)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
exchanges the values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/swap/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23596\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::swap (\fBstring_t\fP & other)\fR [inline]\fP"

.PP
exchanges the values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/swap/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23657\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::swap (typename binary_t::container_type & other)\fR [inline]\fP"

.PP
exchanges the values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/swap/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23689\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> std::vector< std::uint8_t > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_bjdata (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, const bool use_size = \fRfalse\fP, const bool use_type = \fRfalse\fP, const \fBbjdata_version_t\fP version = \fRbjdata_version_t::draft2\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a BJData serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_bjdata/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24471\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_bjdata (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< char > o, const bool use_size = \fRfalse\fP, const bool use_type = \fRfalse\fP, const \fBbjdata_version_t\fP version = \fRbjdata_version_t::draft2\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a BJData serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_bjdata/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24492\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_bjdata (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< std::uint8_t > o, const bool use_size = \fRfalse\fP, const bool use_type = \fRfalse\fP, const \fBbjdata_version_t\fP version = \fRbjdata_version_t::draft2\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a BJData serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_bjdata/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24483\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> std::vector< std::uint8_t > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_bson (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j)\fR [inline]\fP, \fR [static]\fP"

.PP
create a BSON serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_bson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24501\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_bson (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< char > o)\fR [inline]\fP, \fR [static]\fP"

.PP
create a BSON serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_bson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24517\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_bson (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< std::uint8_t > o)\fR [inline]\fP, \fR [static]\fP"

.PP
create a BSON serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_bson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24510\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> std::vector< std::uint8_t > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_cbor (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j)\fR [inline]\fP, \fR [static]\fP"

.PP
create a CBOR serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_cbor/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24398\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_cbor (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< char > o)\fR [inline]\fP, \fR [static]\fP"

.PP
create a CBOR serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_cbor/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24414\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_cbor (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< std::uint8_t > o)\fR [inline]\fP, \fR [static]\fP"

.PP
create a CBOR serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_cbor/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24407\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> std::vector< std::uint8_t > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_msgpack (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j)\fR [inline]\fP, \fR [static]\fP"

.PP
create a MessagePack serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_msgpack/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24421\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_msgpack (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< char > o)\fR [inline]\fP, \fR [static]\fP"

.PP
create a MessagePack serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_msgpack/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24437\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_msgpack (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< std::uint8_t > o)\fR [inline]\fP, \fR [static]\fP"

.PP
create a MessagePack serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_msgpack/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24430\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> std::vector< std::uint8_t > \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_ubjson (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, const bool use_size = \fRfalse\fP, const bool use_type = \fRfalse\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a UBJSON serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_ubjson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24444\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_ubjson (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< char > o, const bool use_size = \fRfalse\fP, const bool use_type = \fRfalse\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a UBJSON serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_ubjson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24463\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::to_ubjson (const \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, \fBdetail::output_adapter\fP< std::uint8_t > o, const bool use_size = \fRfalse\fP, const bool use_type = \fRfalse\fP)\fR [inline]\fP, \fR [static]\fP"

.PP
create a UBJSON serialization of a given JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/to_ubjson/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24455\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBvalue_t\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::type () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"

.PP
return the type of the JSON value (explicit) 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/type/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB21425\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_HEDLEY_RETURNS_NON_NULL\fP const char * \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::type_name () const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
return the type as string 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/type_name/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24301\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBbasic_json\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::unflatten () const\fR [inline]\fP"

.PP
unflatten a previously flattened JSON value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/unflatten/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24847\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::update (\fBconst_iterator\fP first, \fBconst_iterator\fP last, bool merge_objects = \fRfalse\fP)\fR [inline]\fP"

.PP
updates a JSON object from another object, overwriting existing keys 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/update/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23549\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::update (\fBconst_reference\fP j, bool merge_objects = \fRfalse\fP)\fR [inline]\fP"

.PP
updates a JSON object from another object, overwriting existing keys 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/update/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23542\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, class BasicJsonType, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >::value &&\fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (const ::nlohmann::json_pointer< BasicJsonType > & ptr, const ValueType & default_value) const\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB22509\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, class BasicJsonType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< \fBdetail::is_basic_json\fP< BasicJsonType >::value &&\fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (const ::nlohmann::json_pointer< BasicJsonType > & ptr, ValueType && default_value) const\fR [inline]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB22520\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, \fBdetail::enable_if_t\fP< \fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (const \fBjson_pointer\fP & ptr, const ValueType & default_value) const\fR [inline]\fP"

.PP
access specified object element via JSON Pointer with default value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/value/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22458\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< \fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (const \fBjson_pointer\fP & ptr, ValueType && default_value) const\fR [inline]\fP"

.PP
access specified object element via JSON Pointer with default value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/value/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22484\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, \fBdetail::enable_if_t\fP< !\fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&\fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (const typename object_t::key_type & key, const ValueType & default_value) const\fR [inline]\fP"

.PP
access specified object element with default value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/value/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22357\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< !\fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&\fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (const typename object_t::key_type & key, ValueType && default_value) const\fR [inline]\fP"

.PP
access specified object element with default value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/value/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22382\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, class KeyType, \fBdetail::enable_if_t\fP< \fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&!\fBdetail::is_json_pointer\fP< KeyType >::value &&\fBis_comparable_with_object_key\fP< KeyType >::value &&\fBdetail::is_getable\fP< basic_json_t, ValueType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ValueType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (KeyType && key, const ValueType & default_value) const\fR [inline]\fP"

.PP
access specified object element with default value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/value/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22408\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<class ValueType, class KeyType, class ReturnType = typename value_return_type<ValueType>::type, \fBdetail::enable_if_t\fP< \fBdetail::is_transparent\fP< \fBobject_comparator_t\fP >::value &&!\fBdetail::is_json_pointer\fP< KeyType >::value &&\fBis_comparable_with_object_key\fP< KeyType >::value &&\fBdetail::is_getable\fP< basic_json_t, ReturnType >::value &&!std::is_same< \fBvalue_t\fP, \fBdetail::uncvref_t\fP< ValueType > >::value, int > = 0> ReturnType \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::value (KeyType && key, ValueType && default_value) const\fR [inline]\fP"

.PP
access specified object element via JSON Pointer with default value 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/value/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB22435\fP 번째 라인에서 정의되었습니다\&.
.SH "Friend, 그리고 관련된 함수 문서화"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, typename InputType, typename SAX> friend class ::nlohmann::detail::binary_reader\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20220\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, typename CharType> friend class ::nlohmann::detail::binary_writer\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20218\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> friend class ::nlohmann::detail::exception\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20225\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType> friend class ::nlohmann::detail::iter_impl\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20216\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, typename InputAdapterType> friend class ::nlohmann::detail::json_sax_dom_callback_parser\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20224\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, typename InputAdapterType> friend class ::nlohmann::detail::json_sax_dom_parser\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20222\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename BasicJsonType, typename InputType> friend class ::nlohmann::detail::parser\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20213\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<typename> friend class ::nlohmann::json_pointer\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20208\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> template<\fBdetail::value_t\fP> friend struct \fBdetail::external_constructor\fP\fR [friend]\fP"

.PP
\fBjson\&.hpp\fP 파일의 \fB20205\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> std::istream & operator<< (\fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j, std::istream & i)\fR [friend]\fP"

.PP
deserialize from stream 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator_gtgt/ 
.RE
.PP
\fB잘못된 코드\fP
.RS 4
This stream operator is deprecated since 3\&.0\&.0 and will be removed in version 4\&.0\&.0 of the library\&. Please use \fBoperator>>(std::istream&, basic_json&)\fP instead; that is, replace calls like \fRj << i;\fP with \fRi >> j;\fP\&. 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24279\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> std::istream & operator>> (std::istream & i, \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass > & j)\fR [friend]\fP"

.PP
deserialize from stream 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/operator_gtgt/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB24286\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> void swap (\fBreference\fP left, \fBreference\fP right)\fR [friend]\fP"

.PP
exchanges the values 
.PP
\fB참고\fP
.RS 4
https://json.nlohmann.me/api/basic_json/swap/ 
.RE
.PP

.PP
\fBjson\&.hpp\fP 파일의 \fB23613\fP 번째 라인에서 정의되었습니다\&.
.SH "멤버 데이터 문서화"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_PRIVATE_UNLESS_TESTED\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::__pad3__"

.PP
\fBjson\&.hpp\fP 파일의 \fB23785\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_PRIVATE_UNLESS_TESTED\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::__pad4__"

.PP
\fBjson\&.hpp\fP 파일의 \fB24328\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_PRIVATE_UNLESS_TESTED\fP \fBconst_reference\fP bool \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::inverse"

.PP
\fBjson\&.hpp\fP 파일의 \fB23791\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBdata\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::m_data = {}"

.PP
\fBjson\&.hpp\fP 파일의 \fB24364\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> json_value \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::m_value = {}"

.PP
the value of the current element 
.PP
\fBjson\&.hpp\fP 파일의 \fB24339\fP 번째 라인에서 정의되었습니다\&.
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>, class CustomBaseClass = void> \fBJSON_PRIVATE_UNLESS_TESTED\fP \fBconst_reference\fP \fBbasic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass >::rhs"

.PP
\fBjson\&.hpp\fP 파일의 \fB23791\fP 번째 라인에서 정의되었습니다\&.

.SH "작성자"
.PP 
소스 코드로부터 Engine를 위해 Doxygen에 의해 자동으로 생성됨\&.
