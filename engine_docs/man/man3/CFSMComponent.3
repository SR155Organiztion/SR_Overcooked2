.TH "CFSMComponent" 3 "Version 1.0" "Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CFSMComponent
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <CFSMComponent\&.h>\fP
.PP
\fBCComponent\fP를(을) 상속했습니다\&.
.SS "Public 멤버 함수"

.in +1c
.ti -1c
.RI "virtual \fB_int\fP \fBUpdate_Component\fP (const \fB_float\fP &fTimeDelta) override"
.br
.RI "Update타임 @detail 현재 State가 있는지 확인(예외처리), State_Update와 TestForExit를 순환 "
.ti -1c
.RI "virtual void \fBLateUpdate_Component\fP () override"
.br
.ti -1c
.RI "HRESULT \fBReady_FSMComponent\fP ()"
.br
.ti -1c
.RI "void \fBAdd_State\fP (std::string stateName, \fBCState\fP *_state)"
.br
.RI "State 추가 @detail 키값 string, "
.ti -1c
.RI "void \fBChange_State\fP (std::string stateName)"
.br
.RI "State 전환 @detail 보통 TestForExit 시점에 넣는걸 강력 "권장" "
.ti -1c
.RI "std::string \fBGerCurrStateName\fP () const"
.br
.RI "현재 가리키고 있는 State 탐색 "
.ti -1c
.RI "virtual \fBCComponent\fP * \fBClone\fP () override"
.br
.ti -1c
.RI "void \fBSet_Owner\fP (\fBCGameObject\fP *pOwner)"
.br
.RI "상태머신의 주체(주인) 설정 "
.in -1c
.SS "정적 Public 멤버 함수"

.in +1c
.ti -1c
.RI "static \fBCFSMComponent\fP * \fBCreate\fP (LPDIRECT3DDEVICE9 pGraphicDev)"
.br
.RI "컴포넌트 생성 @detail 생성 후 컴포넌트의 Set_Owner 반드시 호출할 것 "
.in -1c
.SS "추가로 상속된 멤버들"


\fBCComponent\fP(으)로부터 상속된 Protected 멤버 함수
.in +1c
.ti -1c
.RI "\fBCComponent\fP ()"
.br
.ti -1c
.RI "\fBCComponent\fP (LPDIRECT3DDEVICE9 pGraphicDev)"
.br
.ti -1c
.RI "\fBCComponent\fP (const \fBCComponent\fP &rhs)"
.br
.ti -1c
.RI "virtual \fB~CComponent\fP ()"
.br
.in -1c

\fBCComponent\fP(으)로부터 상속된 Protected 속성
.in +1c
.ti -1c
.RI "LPDIRECT3DDEVICE9 \fBm_pGraphicDev\fP"
.br
.ti -1c
.RI "\fB_bool\fP \fBm_bClone\fP"
.br
.in -1c
.SH "상세한 설명"
.PP 
\fBCFSMComponent\&.h\fP 파일의 \fB13\fP 번째 라인에서 정의되었습니다\&.
.SH "멤버 함수 문서화"
.PP 
.SS "void CFSMComponent::Add_State (std::string stateName, \fBCState\fP * _state)"

.PP
State 추가 @detail 키값 string, 
.PP
\fB매개변수\fP
.RS 4
\fIstateName\fP - string으로 이루어진 "key" , _state - 여기에서 State 동적할당하는것을 추천 new CStateMove 
.RE
.PP

.PP
\fBCFSMComponent\&.cpp\fP 파일의 \fB38\fP 번째 라인에서 정의되었습니다\&.
.SS "void CFSMComponent::Change_State (std::string stateName)"

.PP
State 전환 @detail 보통 TestForExit 시점에 넣는걸 강력 "권장" 
.PP
\fB매개변수\fP
.RS 4
\fIstateName\fP - 등록된 State의 string key 넣을 것 "key" 
.RE
.PP

.PP
\fBCFSMComponent\&.cpp\fP 파일의 \fB43\fP 번째 라인에서 정의되었습니다\&.
.SS "\fBCComponent\fP * CFSMComponent::Clone ()\fR [override]\fP, \fR [virtual]\fP"

.PP
\fBCComponent\fP(으)로부터 재구현되었습니다\&.
.PP
\fBCFSMComponent\&.cpp\fP 파일의 \fB67\fP 번째 라인에서 정의되었습니다\&.
.SS "\fBCFSMComponent\fP * CFSMComponent::Create (LPDIRECT3DDEVICE9 pGraphicDev)\fR [static]\fP"

.PP
컴포넌트 생성 @detail 생성 후 컴포넌트의 Set_Owner 반드시 호출할 것 
.PP
\fBCFSMComponent\&.cpp\fP 파일의 \fB53\fP 번째 라인에서 정의되었습니다\&.
.SS "std::string CFSMComponent::GerCurrStateName () const\fR [inline]\fP"

.PP
현재 가리키고 있는 State 탐색 
.PP
\fBCFSMComponent\&.h\fP 파일의 \fB51\fP 번째 라인에서 정의되었습니다\&.
.SS "virtual void CFSMComponent::LateUpdate_Component ()\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
\fBCComponent\fP(으)로부터 재구현되었습니다\&.
.PP
\fBCFSMComponent\&.h\fP 파일의 \fB33\fP 번째 라인에서 정의되었습니다\&.
.SS "HRESULT CFSMComponent::Ready_FSMComponent ()"

.PP
\fBCFSMComponent\&.cpp\fP 파일의 \fB33\fP 번째 라인에서 정의되었습니다\&.
.SS "void CFSMComponent::Set_Owner (\fBCGameObject\fP * pOwner)\fR [inline]\fP"

.PP
상태머신의 주체(주인) 설정 
.PP
\fB매개변수\fP
.RS 4
\fICGameObject*\fP pOwner - 보통 자기 자신 넣어주면됨 (this)
.RE
.PP
State의 소유자 설정 @detail 컴포넌트 생성 후 바로 넣는걸 강력 "권장"\&. Set_Owner(this)로 넣는걸 추천 
.PP
\fBCFSMComponent\&.h\fP 파일의 \fB68\fP 번째 라인에서 정의되었습니다\&.
.SS "\fB_int\fP CFSMComponent::Update_Component (const \fB_float\fP & fTimeDelta)\fR [override]\fP, \fR [virtual]\fP"

.PP
Update타임 @detail 현재 State가 있는지 확인(예외처리), State_Update와 TestForExit를 순환 
.PP
\fBCComponent\fP(으)로부터 재구현되었습니다\&.
.PP
\fBCFSMComponent\&.cpp\fP 파일의 \fB23\fP 번째 라인에서 정의되었습니다\&.

.SH "작성자"
.PP 
소스 코드로부터 Engine를 위해 Doxygen에 의해 자동으로 생성됨\&.
